! docentry="Ravl.Core.IO"
! author="Charles Galambos, Bill Christmas"
: Input Output system

<p> There are two mechanisms for doing I/O in RAVL: via streams, and
via the <code>Load()</code> / <code>Save()</code> functions.  The
stream mechanism is general, whereas the <code>Load()</code> /
<code>Save()</code> mechanism is useful where there is a choice of
file formats, or where implicit data conversion is needed.

There is also a mechanism for dealing with sequences of objects a
description of which can be found in <a
href="Ravl.OS.Sequence.html">Ravl.OS.Sequence</a>.

<h2> <a name="LoadSave"></a>Using the <a href=
"../Class/RavlN.LoadObconst_StringC_Amp_DataT_Amp_StringC_boolCb.html">
<code>Load()</code></a> / <a href=
"../Class/RavlN.SaveObconst_StringC_Amp_const_DataT_Amp_StringC_boolCb.html"> <code>Save()</code></a> functions</h2>

The <code>Load()</code> / <code>Save()</code> global functions provide a more
sophisticated I/O mechanism.  They were originally developed for the <a
href="../Class/RavlImageN.ImageC.html">ImageC</a> template class (see <a
href="Ravl.Images.IO.html">Image I/O</a>), but are now available for 
other classes as well.  The mechanism identifies the type of file being loaded,
and selects the appropriate code for loading it, if it exists.  It will also do
certain type conversions automatically where its is deemed safe to do so.  The
algorithm picks the conversion with the least conversion cost, resolving any
ambiguity by using the format with the highest priority.

<p>For example, to read a real image from an RAVL ASCII file (i.e. the same
format as the previous streams example), and store it in a pgm file:

<pre>
ImageC&lt;RealT&gt; x;
Load("fred", x);
Save("jim.pgm", x);
</pre>

The pixel type in the file "fred" is unknown at compile time; the appropriate
type conversion therefore has to be selected at run time.

<p> A more complete example of how to use this mechanism is given in <a
href="../../../Auto/Examples/exFileFormat.cc.html">exFileFormat.cc</a>.  To use this
mechanism you'll have to include the <code>RavlIO</code> library in
<code>defs.mk</code>:

<pre> USESLIBS = RavlIO .... </pre>

<p>A list of currently supported formats can be obtained with the
<code>conv</code> program: 
<pre> conv -lf </pre>

 A list of automatic type conversions that are available can also be found:
<pre> conv -lc </pre>

<p> <b>N.B.</b> the increase in size of your executable from this library can be <font size = +4>large</font>, because all of
the possible formats and conversions have to be allowed for at compile/link
time.


<h2> Writing your own stuff </h2>


<h4>Simple Class IO</h4>

Writing your own file IO is a little more complicated. If all you want to do is
load and save your own class, write basic stream operators for your class and
then instantiate an instance of FileFormatStreamC class as a global variable.
The following example shows how a file format for loading and saving RealT was
created.

<pre>
#include "Ravl/DP/FileFormatStream.hh"

FileFormatStreamC &lt;RealT&gt; FileFormatStream_RealT;
</pre>

<h4>Writing Conversions</h4>

Writing your own data conversion classes is not much more difficult. You have
to write a simple function which does the conversion and then instantiate an
instance of the converter class DPConverterFuncC.  The following example shows
the standard code for converting IntT's to RealT's. Note this conversion is
safe since no information is lost. Care must be taken when writing these
functions, especially if you lose information in the conversion, as it can lead
to unexpected results.  The final parameter (= 1 in this example) indicates the
degree of loss. (1 indicates no loss; 8 used to indicate double -> unsigned
byte).

<pre>
#include "Ravl/DP/Converter.hh"

RealT DPConvIntT2RealT(const IntT &val) 
{ return (RealT) val; }

DP_REGISTER_CONVERTION(DPConvIntT2RealT,1);
</pre>

<h4>Creating a new file format</h4>

The procedure for creating entirely new file formats is more involved. I'll
give only an outline of the procedure here:

<ol>

<li> Create a new class each format that you wish to add one for loading and
one for saving. These shoud be derived from DPIPortBodyC<> and DPOPortBodyC<>
respectively.

<li> Create a new FileFormatXXXC class derived from FileFormatBodyC. In this
class overide the virtuals functions which identify the file format and create
the input and output streams.

<li> Create a static instance of the new file format class, to register it with
the IO mechansim.

</ol>

