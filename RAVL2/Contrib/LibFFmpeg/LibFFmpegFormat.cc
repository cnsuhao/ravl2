// This file is part of RAVL, Recognition And Vision Library 
// Copyright (C) 2003, Omniperception Ltd.
// This code may be redistributed under the terms of the GNU Lesser
// General Public License (LGPL). See the lgpl.licence file for details or
// see http://www.gnu.org/copyleft/lesser.html
// file-header-ends-here
//////////////////////////////////////////////////////////////////
//! rcsid = "$Id: LibFFmpegFormat.cc 7393 2009-11-26 11:38:25Z simondennis $"
//! lib=RavlLibFFmpeg
//! author = "Warren Moore"
//! file="Ravl/Contrib/LibFFmpeg/LibFFmpegFormat.cc"

#ifndef __STDC_CONSTANT_MACROS
#define __STDC_CONSTANT_MACROS 1
#include <stdint.h>
#endif

#include "Ravl/Image/LibFFmpegFormat.hh"
#include "Ravl/Image/ImgIOFFmpeg.hh"
#include "Ravl/Image/ImgDPOFFmpeg.hh"
#include <ctype.h>
#include "Ravl/DP/ByteFileIO.hh"
#include "Ravl/DP/SPortAttach.hh"
#include "Ravl/Image/FFmpegPacketStream.hh"
#include "Ravl/Image/FFmpegEncodePacketStream.hh"
#include "Ravl/Image/FFmpegVideoDecoder.hh"
#include "Ravl/Image/FFmpegVideoEncoder.hh"
#include "Ravl/OS/Filename.hh"

extern "C" {
#if defined(LIBAVFORMAT_VERSION_MAJOR) && LIBAVFORMAT_VERSION_MAJOR >= 52
#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>
#else 
#include <avcodec.h>
#include <avformat.h>
#endif
}

#define DODEBUG 0

#if DODEBUG
#define ONDEBUG(x) x
#else
#define ONDEBUG(x)
#endif

namespace RavlImageN
{
  
  void InitLibFFmpegFormat()
  {}



  FileFormatLibFFmpegBodyC::FileFormatLibFFmpegBodyC() :
    FileFormatBodyC("ffmpeg", "FFmpeg file input.")
  {
    av_register_all();
  }
  
  FileFormatLibFFmpegBodyC::FileFormatLibFFmpegBodyC(const StringC &vName,const StringC &vDesc) :
     FileFormatBodyC(vName,vDesc)
 {}
  
  const type_info &FileFormatLibFFmpegBodyC::ProbeLoad(IStreamC &in, const type_info &obj_type) const
  {
    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::ProbeLoad(IStreamC &,...) called" << endl);
    
    if (!in.good())
      return typeid(void);
    
    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::ProbeLoad(IStreamC&,...) not an FFmpeg supported file" << endl);
    return typeid(void); 
  }



  const type_info &FileFormatLibFFmpegBodyC::ProbeLoad(const StringC &filename,
                                                      IStreamC &in,
                                                      const type_info &obj_type) const
  {
    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::ProbeLoad(const StringC&,IStreamC&,...) called (" << filename << ")" << endl);
    
    if (!in.good())
      return typeid(void);

    FilenameC filenameObject(filename);
    StringC extension = downcase(filenameObject.Extension());
    // Discarding common image file extensions from http://ffmpeg.org/general.html#SEC5
    // Note: FFmpegPacketStream::CheckForVideo will discard all sequences composed of separate image files,
    // but this will make ProbeLoad quicker (and reduce the console messages generated by FFmpeg)
    if (extension == "png" || \
        extension == "jpg" || \
        extension == "jpeg" || \
        extension == "gif" || \
        extension == "bmp" || \
        extension == "ppm" || \
        extension == "pnm" || \
        extension == "pgm" || \
        extension == "tif" || \
        extension == "tiff" || \
        extension == "yuv" || \
        extension == "tga")
    {
      ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::ProbeLoad(const StringC&,IStreamC&,...) unsupported extension for file (" << filename << ")" << endl);
      return typeid(void);
    }

    if (IsSupported(filename.chars()))
    {
      return typeid(ImageC<ByteRGBValueC>);
    }
    
    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::ProbeLoad(const StringC&,IStreamC&,...) not an FFmpeg supported file (" << filename << ")" << endl);
    return typeid(void);
  }



  const type_info &FileFormatLibFFmpegBodyC::ProbeSave(const StringC &filename,
                                                       const type_info &obj_type,
                                                       bool forceFormat ) const
  { 
    //At the moment only support mpg files thru ffmpeg
    if((FilenameC(filename).Extension() == "h264") || (FilenameC(filename).Extension() == "mpg")) {
    if (IsOutPutSupported(filename.chars()))
    {
      ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::ProbeSave(const StringC&,OStreamC&,...) supported ffmpeg file  (" << filename << ")" << endl);
      return typeid(ImageC<ByteRGBValueC>);
    }
    }
    //else {
    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::ProbeSave(const StringC&,OStreamC&,...) not an FFmpeg supported file (" << filename << ")" << endl);
    return typeid(void);
    //}
    //ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::ProbeSave(const StringC&,...) not supported" << endl);
    //return typeid(void);   
  }


  
  DPIPortBaseC FileFormatLibFFmpegBodyC::CreateInput(const StringC &filename, const type_info &obj_type) const
  {
    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::CreateInput(const StringC&,...) called (" << filename << ")" << endl);
    
    if (IsSupported(filename.chars()))
    {
      //return SPort(DPIByteFileC(fn) >> ImgILibFFmpegC(true));
      FFmpegPacketStreamC packetStream(filename);
      IntT codecId = -1;
      IntT videoStreamId = -1;
      if(!packetStream.FirstVideoStream(videoStreamId,codecId))
        return DPIPortBaseC();
      return ImgIOFFmpegC<ImageC<ByteRGBValueC> >(packetStream,videoStreamId,codecId);
    }
    
    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::CreateInput(const StringC&,...) not an FFmpeg supported file (" << filename << ")" << endl);
    return DPIPortBaseC();
  }



  DPOPortBaseC FileFormatLibFFmpegBodyC::CreateOutput(const StringC &filename, const type_info &obj_type) const
  {

    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::CreateOutput(const StringC&,...) called (" << filename << ")" << endl);
    
    if (IsOutPutSupported(filename.chars()))
    {
      //return SPort(DPIByteFileC(fn) >> ImgILibFFmpegC(true));
      FFmpegEncodePacketStreamC packetStream(filename);
      IntT codecId = -1;
      IntT videoStreamId = -1;
        ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::CreateOutput(const StringC&,...) if(!packetStream. " << endl);
      if(!packetStream.FirstVideoStream(videoStreamId,codecId)) {
        ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::CreateOutput(const StringC&,...) error. " << endl);
        return DPOPortBaseC();
      }
        ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::CreateOutput(const StringC&,...) return ImgDPOFFmpeg. " << endl);
        ImgDPOFFmpegC<ImageC<ByteRGBValueC> > temp(packetStream,videoStreamId,codecId);
        ONDEBUG(cerr << "after ImgDPOFFmpegC " << endl);
        ImageC<ByteRGBValueC> brgb;
        IntT result;
        ONDEBUG(cerr << "call put " << result << " temp.Put(brbg).typeid() is " << typeid(temp).name() <<  endl);
        result = temp.IsPutReady();  //Put(brgb);
        ONDEBUG(cerr << "result is " << result << endl);
        return temp;
    }
    
    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::CreateOutput(const StringC&,...) not an FFmpeg supported file (" << filename << ")" << endl);

    return DPOPortBaseC();  
  }



  DPIPortBaseC FileFormatLibFFmpegBodyC::CreateInput(IStreamC &in, const type_info &obj_type) const
  {
    return DPIPortBaseC();
  }



  DPOPortBaseC FileFormatLibFFmpegBodyC::CreateOutput(OStreamC &out, const type_info &obj_type) const
  {
    return DPOPortBaseC();  
  }



  const type_info &FileFormatLibFFmpegBodyC::DefaultType() const
  { 
    return typeid(ImageC<ByteRGBValueC>); 
  }



  bool FileFormatLibFFmpegBodyC::IsSupported(const char *filename) const
  {
    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::IsSupported(const char *) called (" << filename << ")" << endl);
    FFmpegPacketStreamC stream(true);
    bool ret = false;
    if(stream.Open(filename)) 
      ret = stream.CheckForVideo();
    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::IsSupported(const char *) " << (ret ? "succeeded" : "failed") << endl);
    return ret;
  }
  
  bool FileFormatLibFFmpegBodyC::IsOutPutSupported(const char *filename) const
  {
    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::IsOutPutSupported(const char *) called (" << filename << ")" << endl);
    FFmpegEncodePacketStreamC stream(true);
    bool ret = false;
    if(stream.Open(filename)) {
      //ret = stream.CheckForVideo();
      ret = true;
    }
    ONDEBUG(cerr << "FileFormatLibFFmpegBodyC::IsOutPutSupported(const char *) " << (ret ? "succeeded" : "failed") << endl);
    return ret;
  }  

  
  static FileFormatLibFFmpegC Init;  

    FileFormatLibFFmpegC RegisterFileFormatLibFFmpegmpg  ("mpg",".mpg file output.");
    FileFormatLibFFmpegC RegisterFileFormatLibFFmpegh264  ("h264",".h264 file output.");

}
